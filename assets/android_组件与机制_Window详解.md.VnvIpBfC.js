import{_ as o,c as d,o as i,aj as a}from"./chunks/framework.BiF827kf.js";const u=JSON.parse('{"title":"Android Window 体系详解","description":"","frontmatter":{},"headers":[],"relativePath":"android/组件与机制/Window详解.md","filePath":"android/组件与机制/Window详解.md","lastUpdated":1759056152000}'),t={name:"android/组件与机制/Window详解.md"};function l(c,e,r,n,s,w){return i(),d("div",null,[...e[0]||(e[0]=[a('<h1 id="android-window-体系详解" tabindex="-1">Android Window 体系详解 <a class="header-anchor" href="#android-window-体系详解" aria-label="Permalink to “Android Window 体系详解”">​</a></h1><h2 id="_1-window-的角色定位" tabindex="-1">1. Window 的角色定位 <a class="header-anchor" href="#_1-window-的角色定位" aria-label="Permalink to “1. Window 的角色定位”">​</a></h2><ul><li><strong>抽象定义</strong>：Window 是 Android 中展示视图与接收输入的顶层容器，<code>android.view.Window</code> 为抽象类，Activity、Dialog、Toast 等都通过具体 Window 实例进行展示。</li><li><strong>三层结构</strong>： <ol><li><strong>Window 对象</strong>：负责管理 DecorView、WindowManager.LayoutParams、回调等。</li><li><strong>DecorView</strong>：窗口顶级 View，包含系统装饰（状态栏、导航栏占位等）和内容区域。</li><li><strong>ViewRootImpl</strong>：连接 View 世界与 WindowManagerService (WMS) 的桥梁，处理绘制、输入、窗口变更。</li></ol></li><li><strong>系统服务协作</strong>：Window 的创建、更新、销毁由 WindowManagerService 统一调度，与 SurfaceFlinger 协作完成最终展示。</li></ul><h2 id="_2-windowmanager-与-wms" tabindex="-1">2. WindowManager 与 WMS <a class="header-anchor" href="#_2-windowmanager-与-wms" aria-label="Permalink to “2. WindowManager 与 WMS”">​</a></h2><ul><li><code>WindowManager</code> 是应用侧接口，实际调用 <code>WindowManagerGlobal</code>。</li><li><code>WindowManagerService</code> (WMS) 是系统服务，负责： <ul><li>管理窗口层级、Z-Order、动画、输入焦点。</li><li>与 ActivityTaskManager 协作维护 Activity/Task 可见性。</li><li>分配 Surface、控制尺寸与位置、响应旋转与多窗口。</li></ul></li><li>交互过程： <ol><li>应用通过 <code>WindowManager.addView()</code> 提交 <code>ViewRootImpl</code> 创建请求。</li><li><code>ViewRootImpl</code> 通过 Binder 调用 WMS 的 <code>addWindow()</code>。</li><li>WMS 校验权限、窗口类型、token，创建或复用 <code>SurfaceControl</code>。</li><li>WMS 通知 <code>ViewRootImpl</code> 初始化绘制和输入渠道。</li></ol></li></ul><h2 id="_3-activity-与-window" tabindex="-1">3. Activity 与 Window <a class="header-anchor" href="#_3-activity-与-window" aria-label="Permalink to “3. Activity 与 Window”">​</a></h2><ul><li>Activity 启动时 <code>ActivityThread.handleLaunchActivity()</code> 调用 <code>Activity.attach()</code>，创建 <code>PhoneWindow</code>。</li><li><code>setContentView()</code> 实际调用 <code>PhoneWindow.setContentView()</code>，将布局加载到 DecorView 的 <code>mContentParent</code>。</li><li><code>ActivityThread.handleResumeActivity()</code> 中 <code>WindowManager.addView(decorView)</code> 完成窗口添加。</li><li>生命周期变化时通过 <code>WindowManager.updateViewLayout()</code> 调整布局参数，退出时调用 <code>removeViewImmediate()</code>。</li></ul><h2 id="_4-window-类型与层级" tabindex="-1">4. Window 类型与层级 <a class="header-anchor" href="#_4-window-类型与层级" aria-label="Permalink to “4. Window 类型与层级”">​</a></h2><ul><li><code>WindowManager.LayoutParams.type</code> 决定窗口层级与权限： <ul><li><strong>应用窗口</strong> (<code>TYPE_APPLICATION</code>、<code>TYPE_APPLICATION_PANEL</code> 等)：Activity、Dialog。</li><li><strong>子窗口</strong> (<code>TYPE_APPLICATION_SUB_PANEL</code> 等)：依附于父窗口，如 PopupWindow。</li><li><strong>系统窗口</strong> (<code>TYPE_SYSTEM_ALERT</code>、<code>TYPE_APPLICATION_OVERLAY</code>)：需 MANAGE_OVERLAY_PERMISSION。</li></ul></li><li>层级影响焦点、触控穿透与覆盖关系；WMS 根据 type、token、Z-order 排序。</li></ul><h2 id="_5-layoutparams-关键字段" tabindex="-1">5. LayoutParams 关键字段 <a class="header-anchor" href="#_5-layoutparams-关键字段" aria-label="Permalink to “5. LayoutParams 关键字段”">​</a></h2><ul><li><strong>尺寸</strong>：<code>width/height</code> 支持 MATCH_PARENT、WRAP_CONTENT、自定义像素。</li><li><strong>位置</strong>：<code>gravity</code>、<code>x/y</code>、<code>layoutInDisplayCutoutMode</code> 控制布局。</li><li><strong>标志位</strong>：<code>flags</code>（如 <code>FLAG_FULLSCREEN</code>、<code>FLAG_KEEP_SCREEN_ON</code>、<code>FLAG_NOT_FOCUSABLE</code>）。</li><li><strong>输入</strong>：<code>softInputMode</code>、<code>inputFeatures</code>、<code>dimAmount</code> 影响输入法与背景遮罩。</li><li><strong>动画</strong>：<code>windowAnimations</code> 指定进入/退出动画资源。</li></ul><h2 id="_6-decorview-结构" tabindex="-1">6. DecorView 结构 <a class="header-anchor" href="#_6-decorview-结构" aria-label="Permalink to “6. DecorView 结构”">​</a></h2><ul><li>根节点通常为 <code>FrameLayout</code>，包含： <ul><li><strong>StatusBar/NavigationBar 占位</strong>：<code>ViewStub</code> 动态填充。</li><li><strong>ActionBar/Toolbar 区域</strong>。</li><li><strong>内容区</strong>：<code>android.R.id.content</code>。</li></ul></li><li><code>setContentView()</code> 将布局添加到内容区。</li><li><code>DecorView</code> 实现了 <code>Callback</code> 接口，分发按键、触摸事件给 Activity。</li></ul><h2 id="_7-viewrootimpl-职责" tabindex="-1">7. ViewRootImpl 职责 <a class="header-anchor" href="#_7-viewrootimpl-职责" aria-label="Permalink to “7. ViewRootImpl 职责”">​</a></h2><ul><li>管理窗口与 WMS 的通信：<code>relayoutWindow()</code>、<code>setView()</code>、<code>die()</code>。</li><li>维护输入通道 <code>InputChannel</code>，处理触控、键盘事件。</li><li>负责调用 <code>performTraversals()</code> 完成 View 树测量、布局、绘制。</li><li>监听窗口 Insets、配置变化（旋转、尺寸）、Surface 生命周期。</li></ul><h2 id="_8-surface-与渲染" tabindex="-1">8. Surface 与渲染 <a class="header-anchor" href="#_8-surface-与渲染" aria-label="Permalink to “8. Surface 与渲染”">​</a></h2><ul><li>每个窗口关联一个或多个 <code>Surface</code>，由 SurfaceFlinger 合成。</li><li>应用端通过 <code>Surface</code> 的 Canvas 或 Hardware Renderer（RenderThread）绘制内容。</li><li>当窗口尺寸或可见性变化时，<code>ViewRootImpl</code> 会触发 <code>SurfaceChanged</code> 回调，Activity/TextureView 需响应。</li></ul><h2 id="_9-输入与焦点" tabindex="-1">9. 输入与焦点 <a class="header-anchor" href="#_9-输入与焦点" aria-label="Permalink to “9. 输入与焦点”">​</a></h2><ul><li><code>InputDispatcher</code> 根据 WMS 的焦点窗口列表分发事件。</li><li><code>Window</code> 可通过 <code>FLAG_NOT_FOCUSABLE</code>、<code>FLAG_NOT_TOUCHABLE</code> 控制输入策略。</li><li><code>Window.Callback</code>（Activity/Dialog 实现）处理 <code>dispatchKeyEvent</code>、<code>onWindowFocusChanged</code>。</li><li>多窗口/分屏模式下，焦点窗口随着前台任务变化，WMS 同步通知相关应用。</li></ul><h2 id="_10-特殊窗口与场景" tabindex="-1">10. 特殊窗口与场景 <a class="header-anchor" href="#_10-特殊窗口与场景" aria-label="Permalink to “10. 特殊窗口与场景”">​</a></h2><ul><li><strong>Dialog</strong>：内部持有 <code>DialogWindow</code>; 调用 <code>WindowManager.addView()</code> 添加，生命周期跟随 Activity。</li><li><strong>PopupWindow</strong>：通过 <code>TYPE_APPLICATION_PANEL/SUB_PANEL</code> 添加子窗口，可设置背景、动画。</li><li><strong>Toast</strong>：系统级窗口，Android 11 起权限受限；前台应用可使用 <code>TYPE_TOAST</code>。</li><li><strong>悬浮窗</strong>：<code>TYPE_APPLICATION_OVERLAY</code>，需用户授权；系统限制频繁显示。</li><li><strong>Wallpaper/输入法窗口</strong>：特殊 type，对位置、尺寸、输入有特殊管理策略。</li></ul><h2 id="_11-多窗口与显示适配" tabindex="-1">11. 多窗口与显示适配 <a class="header-anchor" href="#_11-多窗口与显示适配" aria-label="Permalink to “11. 多窗口与显示适配”">​</a></h2><ul><li>Android 7.0 引入分屏、多窗口模式；WMS 根据 Task/DisplayArea 组织窗口层次。</li><li>可折叠设备需处理多个 Display、<code>WindowMetrics</code>、<code>WindowLayoutInfo</code>。</li><li><code>WindowInsets</code> API 负责适配刘海、手势导航区域；<code>WindowCompat.setDecorFitsSystemWindows</code> 控制沉浸式体验。</li></ul><h2 id="_12-权限与安全" tabindex="-1">12. 权限与安全 <a class="header-anchor" href="#_12-权限与安全" aria-label="Permalink to “12. 权限与安全”">​</a></h2><ul><li>系统会校验窗口类型是否具备权限（如 Overlay）。</li><li>防控点击劫持：<code>FLAG_SECURE</code> 禁止截屏/录屏；<code>setFilterTouchesWhenObscured</code> 拦截被覆盖时的触控。</li><li>严格遵守最小权限原则，避免滥用全屏/悬浮窗影响用户体验。</li></ul><h2 id="_13-调试工具与排障" tabindex="-1">13. 调试工具与排障 <a class="header-anchor" href="#_13-调试工具与排障" aria-label="Permalink to “13. 调试工具与排障”">​</a></h2><ul><li><code>adb shell dumpsys window</code>：查看窗口层级、属性、焦点状态。</li><li><code>Hierarchy Viewer</code>/<code>Layout Inspector</code>：可视化窗口与 View 结构。</li><li><code>adb shell cmd window</code>：操作窗口模式（如 设置最小化、最大化）。</li><li><code>WindowManager</code> 日志：监控新增/移除窗口、异常。</li><li><code>StrictMode</code> + <code>Window.setCallback</code>：检测窗口回调耗时。</li></ul><h2 id="_14-常见问题与解决策略" tabindex="-1">14. 常见问题与解决策略 <a class="header-anchor" href="#_14-常见问题与解决策略" aria-label="Permalink to “14. 常见问题与解决策略”">​</a></h2><table tabindex="0"><thead><tr><th>问题</th><th>可能原因</th><th>解决建议</th></tr></thead><tbody><tr><td>WindowLeaked 异常</td><td>Activity 销毁时未移除窗口</td><td>在 <code>onDestroy</code> 调用 <code>dismiss()</code> 或 <code>removeViewImmediate()</code></td></tr><tr><td>布局被系统栏遮挡</td><td>没有处理 Insets</td><td>使用 <code>WindowInsetsController</code>、<code>ViewCompat.setOnApplyWindowInsetsListener()</code></td></tr><tr><td>悬浮窗不可见</td><td>未申请权限或被系统限制</td><td>检查 <code>Settings.canDrawOverlays()</code>，适配不同 ROM</td></tr><tr><td>多窗口尺寸异常</td><td>依赖旧的 DisplayMetrics</td><td>使用 <code>WindowMetrics</code>/<code>onConfigurationChanged</code> 重新计算</td></tr><tr><td>输入法遮挡</td><td><code>softInputMode</code> 配置不当</td><td>设置 <code>ADJUST_RESIZE</code> 并监听 Insets</td></tr></tbody></table><h2 id="_15-最佳实践清单" tabindex="-1">15. 最佳实践清单 <a class="header-anchor" href="#_15-最佳实践清单" aria-label="Permalink to “15. 最佳实践清单”">​</a></h2><ul><li>Activity 中使用 <code>WindowCompat</code>、<code>Insets</code> API 实现沉浸式和自适应布局。</li><li>在组件销毁时及时释放窗口，避免内存泄漏与 WindowLeaked。</li><li>针对权限敏感的窗口（Overlay/Toast）提供明确引导，尊重用户体验。</li><li>自定义 Dialog/PopupWindow 注意布局层级与动画，避免 overdraw。</li><li>结合 <code>WindowManager.LayoutParams</code> 与 <code>ViewRootImpl</code> 回调，监控窗口尺寸，必要时动态调整内容布局。</li></ul><hr><p>理解 Window 体系有助于掌握 Android 的界面呈现与系统交互原理，为实现复杂 UI、悬浮窗、多窗口适配提供坚实基础。</p>',33)])])}const _=o(t,[["render",l]]);export{u as __pageData,_ as default};
