import{_ as o,c as i,o as a,ai as l}from"./chunks/framework.4IxF6_6k.js";const m=JSON.parse('{"title":"Android View 绘制机制详解","description":"","frontmatter":{},"headers":[],"relativePath":"android/组件与机制/View详解.md","filePath":"android/组件与机制/View详解.md","lastUpdated":1759056152000}'),r={name:"android/组件与机制/View详解.md"};function d(c,e,t,n,u,s){return a(),i("div",null,[...e[0]||(e[0]=[l('<h1 id="android-view-绘制机制详解" tabindex="-1">Android View 绘制机制详解 <a class="header-anchor" href="#android-view-绘制机制详解" aria-label="Permalink to &quot;Android View 绘制机制详解&quot;">​</a></h1><h2 id="_1-总体流程概览" tabindex="-1">1. 总体流程概览 <a class="header-anchor" href="#_1-总体流程概览" aria-label="Permalink to &quot;1. 总体流程概览&quot;">​</a></h2><ul><li>View 绘制遵循 <strong>measure → layout → draw</strong> 三阶段：测量尺寸、摆放位置、渲染内容。</li><li>绘制由 <code>ViewRootImpl</code> 协调，关联窗口与 <code>View</code> 树，负责响应 VSync、触发遍历与硬件加速管线。</li><li>渲染输出通过 <code>Surface</code> 提供缓冲区，最终由 <code>SurfaceFlinger</code> 合成展示到屏幕。</li></ul><h2 id="_2-启动绘制的触发途径" tabindex="-1">2. 启动绘制的触发途径 <a class="header-anchor" href="#_2-启动绘制的触发途径" aria-label="Permalink to &quot;2. 启动绘制的触发途径&quot;">​</a></h2><ol><li><strong>首次绘制</strong>： <ul><li>Activity <code>setContentView()</code> 后，<code>ViewRootImpl</code> 在 <code>performTraversals</code> 中完成三阶段。</li><li>系统等待 Window 具备尺寸、Surface 可用后开始。</li></ul></li><li><strong>布局/尺寸变化</strong>： <ul><li>调用 <code>requestLayout()</code> 触发 measure/layout，再视情况重新 draw。</li></ul></li><li><strong>内容更新</strong>： <ul><li><code>invalidate()</code> 或 <code>postInvalidate()</code> 标记脏区，只执行 draw。</li></ul></li><li><strong>VSync 驱动</strong>： <ul><li><code>Choreographer</code> 在每帧 VSync 回调 <code>doFrame()</code>，协调输入、动画与绘制顺序。</li></ul></li></ol><h2 id="_3-measure-阶段细节" tabindex="-1">3. measure 阶段细节 <a class="header-anchor" href="#_3-measure-阶段细节" aria-label="Permalink to &quot;3. measure 阶段细节&quot;">​</a></h2><ul><li><strong>MeasureSpec</strong> = 模式 (UNSPECIFIED/EXACTLY/AT_MOST) + 尺寸。</li><li>父容器根据自身布局参数与子 View 的 LayoutParams 计算 MeasureSpec。</li><li><code>View.measure()</code> → <code>onMeasure()</code>：子类可重写确定自身尺寸。</li><li>测量结果存储在 <code>mMeasuredWidth/Height</code>，并通过 <code>setMeasuredDimension()</code> 设置。</li><li>注意： <ul><li>多次测量需保证幂等，避免死循环。</li><li>自定义 View 在 <code>wrap_content</code> 下需给出合理默认值。</li></ul></li></ul><h2 id="_4-layout-阶段细节" tabindex="-1">4. layout 阶段细节 <a class="header-anchor" href="#_4-layout-阶段细节" aria-label="Permalink to &quot;4. layout 阶段细节&quot;">​</a></h2><ul><li><code>View.layout(l,t,r,b)</code> 确定 View 在父容器中的实际位置。</li><li>内部调用 <code>onLayout()</code>，ViewGroup 在此遍历子 View 并调用子 View 的 <code>layout</code>。</li><li>布局完成后，<code>mLeft/mTop/mRight/mBottom</code> 固定；若位置发生变化将触发后续 draw。</li></ul><h2 id="_5-draw-阶段细节" tabindex="-1">5. draw 阶段细节 <a class="header-anchor" href="#_5-draw-阶段细节" aria-label="Permalink to &quot;5. draw 阶段细节&quot;">​</a></h2><ul><li><code>View.draw(Canvas)</code> 逻辑顺序： <ol><li>绘制背景 (<code>drawBackground</code>)。</li><li>保存画布状态 → 调用 <code>onDraw()</code> 绘制内容。</li><li>绘制子元素 (<code>dispatchDraw</code>)；<code>ViewGroup</code> 负责遍历子 View。</li><li>绘制前景（scrollbar、foreground）。</li></ol></li><li>自定义 View 重写 <code>onDraw()</code>，通过 Canvas API 绘制图形文本。</li><li>硬件加速时由 RenderThread 与 GPU 渲染 DisplayList，避免重复计算。</li></ul><h2 id="_6-viewrootimpl-与窗口协作" tabindex="-1">6. ViewRootImpl 与窗口协作 <a class="header-anchor" href="#_6-viewrootimpl-与窗口协作" aria-label="Permalink to &quot;6. ViewRootImpl 与窗口协作&quot;">​</a></h2><ul><li><code>ViewRootImpl</code> 绑定根视图 DecorView，管理： <ul><li>窗口输入队列、绘制遍历、VSYNC 处理、Surface 生命周期。</li></ul></li><li><code>performTraversals()</code> 内部依次执行 <code>performMeasure()</code>、<code>performLayout()</code>、<code>performDraw()</code>。</li><li><code>scheduleTraversals()</code> 通过 <code>Choreographer</code> 注册下一帧回调，确保在 VSync 对齐后执行。</li></ul><h2 id="_7-vsync、choreographer-与渲染管线" tabindex="-1">7. VSync、Choreographer 与渲染管线 <a class="header-anchor" href="#_7-vsync、choreographer-与渲染管线" aria-label="Permalink to &quot;7. VSync、Choreographer 与渲染管线&quot;">​</a></h2><ul><li><code>Choreographer</code> 将每帧工作划分为 Input → Animation → Traversal → Commit 阶段。</li><li>VSync 信号来自 SurfaceFlinger，通过 Binder 传递到应用端 <code>DisplayEventReceiver</code>。</li><li>渲染完成后，<code>ViewRootImpl</code> 调用 <code>Surface.unlockCanvasAndPost()</code> 或 RenderThread 将缓冲区提交给 SurfaceFlinger。</li></ul><h2 id="_8-关键-api-差异" tabindex="-1">8. 关键 API 差异 <a class="header-anchor" href="#_8-关键-api-差异" aria-label="Permalink to &quot;8. 关键 API 差异&quot;">​</a></h2><ul><li><code>invalidate()</code>：当前线程调用（主线程），立即标记脏区；只重绘目标区域。</li><li><code>postInvalidate()</code>：可在子线程调用，内部切换至主线程执行。</li><li><code>requestLayout()</code>：触发 measure/layout/draw；若在 layout 阶段调用会延迟到下一帧。</li><li><code>forceLayout()</code>：强制下次 measure/layout，慎用。</li></ul><h2 id="_9-自定义-view-viewgroup-指南" tabindex="-1">9. 自定义 View/ViewGroup 指南 <a class="header-anchor" href="#_9-自定义-view-viewgroup-指南" aria-label="Permalink to &quot;9. 自定义 View/ViewGroup 指南&quot;">​</a></h2><ol><li><strong>自定义 View</strong>： <ul><li>重写 <code>onMeasure()</code>，处理 <code>wrap_content</code>。</li><li>重写 <code>onDraw()</code>，使用抗锯齿、复用 <code>Paint</code>。</li></ul></li><li><strong>自定义 ViewGroup</strong>： <ul><li>重写 <code>onMeasure()</code>：测量子 View，结合 <code>MarginLayoutParams</code>。</li><li>重写 <code>onLayout()</code>：手动布局子元素。</li><li>如需支持 <code>LayoutParams</code> 扩展，重写 <code>generateLayoutParams</code> 等方法。</li></ul></li><li><strong>性能优化</strong>： <ul><li>减少 View 层级，使用 ConstraintLayout/MotionLayout。</li><li>利用 <code>setWillNotDraw(true)</code> 避免多余绘制。</li><li>缓存复杂绘制结果（如 <code>Bitmap</code>、<code>Picture</code>）。</li></ul></li></ol><h2 id="_10-渲染性能与调优" tabindex="-1">10. 渲染性能与调优 <a class="header-anchor" href="#_10-渲染性能与调优" aria-label="Permalink to &quot;10. 渲染性能与调优&quot;">​</a></h2><ul><li><strong>卡顿分析</strong>： <ul><li><code>adb shell dumpsys gfxinfo &lt;package&gt;</code> 查看每帧耗时。</li><li><code>Profile GPU Rendering</code>、<code>Perfetto</code> 分析渲染负载。</li></ul></li><li><strong>Overdraw 控制</strong>：<code>Debug GPU Overdraw</code> 查看重复绘制区域，优化背景叠加。</li><li><strong>硬件加速注意事项</strong>： <ul><li>Shader、Xfermode、Canvas.saveLayer 可能触发离屏渲染，需评估成本。</li><li>关闭硬件加速 <code>android:hardwareAccelerated=&quot;false&quot;</code> 会退回 CPU 绘制，慎用。</li></ul></li><li><strong>合成与刷新率</strong>：针对 90Hz/120Hz 设备需确保计算阶段 &lt; 帧时长。</li></ul><h2 id="_11-绘制相关常见问题" tabindex="-1">11. 绘制相关常见问题 <a class="header-anchor" href="#_11-绘制相关常见问题" aria-label="Permalink to &quot;11. 绘制相关常见问题&quot;">​</a></h2><ul><li><strong>闪烁/白屏</strong>：布局复杂、首次加载数据延迟；可使用占位图/预绘制。</li><li><strong>布局错位</strong>：<code>onLayout</code> 中误用 child 参数或未考虑 padding/margin。</li><li><strong>MeasureSpec 使用错误</strong>：子 View 忽略父容器模式导致尺寸异常。</li><li><strong>线程安全</strong>：UI 操作必须在主线程；后台线程需通过 Handler/Coroutine 切换。</li><li><strong>动画影响布局</strong>：LayoutParams 改变需调用 <code>requestLayout()</code>；仅视觉变换可用 <code>ViewPropertyAnimator</code>。</li></ul><h2 id="_12-与-compose-的关系" tabindex="-1">12. 与 Compose 的关系 <a class="header-anchor" href="#_12-与-compose-的关系" aria-label="Permalink to &quot;12. 与 Compose 的关系&quot;">​</a></h2><ul><li>Jetpack Compose 底层仍通过 <code>ViewRootImpl</code> 与 Surface 协同，但自身的 Layout/Measure 由 Compose Runtime 管理。</li><li>传统 View 与 Compose 可混合（<code>ComposeView</code>、<code>AndroidView</code>）。</li><li>Compose 的 recomposition 相当于更细粒度的 <code>invalidate</code>，依赖 Choreographer 触发。</li></ul><h2 id="_13-调试工具与日志" tabindex="-1">13. 调试工具与日志 <a class="header-anchor" href="#_13-调试工具与日志" aria-label="Permalink to &quot;13. 调试工具与日志&quot;">​</a></h2><ul><li><code>Layout Inspector</code>/<code>Layout Validation</code>：实时查看 View 树结构与属性。</li><li><code>RenderThread</code> Trace：定位 GPU 负载、DisplayList 构建时间。</li><li><code>StrictMode.setThreadPolicy</code>：捕获主线程长时间绘制或阻塞。</li><li>自定义 <code>ViewTreeObserver.OnDrawListener</code>、<code>OnGlobalLayoutListener</code> 观察布局变化。</li></ul><h2 id="_14-最佳实践清单" tabindex="-1">14. 最佳实践清单 <a class="header-anchor" href="#_14-最佳实践清单" aria-label="Permalink to &quot;14. 最佳实践清单&quot;">​</a></h2><ul><li>设计界面时优先使用约束式布局，减少嵌套与深度遍历。</li><li>合理拆分布局模块，复用 <code>include</code>、<code>merge</code>、<code>ViewStub</code>。</li><li>避免在 <code>onDraw()</code> 中分配对象或进行复杂逻辑。</li><li>对实时更新的视图使用动画与差分工具（如 DiffUtil）降低重绘成本。</li><li>在开发阶段开启过度绘制、布局边界调试，持续优化。</li></ul><hr><p>深入掌握 View 绘制流程，有助于优化界面性能、定位渲染问题，并为自定义控件开发打下坚实基础。</p>',31)])])}const w=o(r,[["render",d]]);export{m as __pageData,w as default};
