import{_ as o,c as a,o as i,ai as l}from"./chunks/framework.aM21JT-d.js";const g=JSON.parse('{"title":"Android 应用启动流程","description":"","frontmatter":{},"headers":[],"relativePath":"android/语言与基础/Android应用启动流程.md","filePath":"android/语言与基础/Android应用启动流程.md","lastUpdated":1759056152000}'),n={name:"android/语言与基础/Android应用启动流程.md"};function t(r,e,s,c,d,p){return i(),a("div",null,[...e[0]||(e[0]=[l(`<h1 id="android-应用启动流程" tabindex="-1">Android 应用启动流程 <a class="header-anchor" href="#android-应用启动流程" aria-label="Permalink to &quot;Android 应用启动流程&quot;">​</a></h1><h2 id="_1-启动场景概览" tabindex="-1">1. 启动场景概览 <a class="header-anchor" href="#_1-启动场景概览" aria-label="Permalink to &quot;1. 启动场景概览&quot;">​</a></h2><ul><li><strong>冷启动（Cold Start）</strong>：进程不存在，系统需从 Zygote 派生新进程，完成资源装载与首帧绘制，耗时最长。</li><li><strong>热启动（Hot Start）</strong>：进程、Activity 均在前台待机，仅需恢复界面，耗时最短。</li><li><strong>温启动（Warm Start）</strong>：进程常驻但界面被销毁，需要重新创建 Activity 并恢复状态。</li></ul><p>在性能分析中，冷启动最具挑战性，Google Play 的核心指标 <code>Time To Full Display</code> 以冷启动为主要评估对象。</p><h2 id="_2-系统底层准备" tabindex="-1">2. 系统底层准备 <a class="header-anchor" href="#_2-系统底层准备" aria-label="Permalink to &quot;2. 系统底层准备&quot;">​</a></h2><ol><li><strong>Zygote 预热</strong>：</li></ol><ul><li>系统开机时启动 <code>Zygote</code> 进程，预加载核心类库（如 <code>core-libart.jar</code>、<code>framework.jar</code>）、资源与 JNI 库。</li><li>注册 <code>Zygote</code> Socket，等待系统请求派生新进程。</li></ul><ol start="2"><li><strong>System Server 启动</strong>：</li></ol><ul><li><code>Zygote</code> fork 出 <code>system_server</code> 进程，初始化 ActivityManagerService（AMS）、PackageManagerService 等核心服务。</li><li><code>ActivityTaskManagerService</code> (ATMS) 与 WindowManagerService (WMS) 准备好调度 Activity 与窗口的能力。</li></ul><h2 id="_3-启动入口-用户点击图标" tabindex="-1">3. 启动入口：用户点击图标 <a class="header-anchor" href="#_3-启动入口-用户点击图标" aria-label="Permalink to &quot;3. 启动入口：用户点击图标&quot;">​</a></h2><ol><li><strong>Launcher 发送意图</strong>：用户点击桌面图标或其他入口，Launcher 通过 <code>startActivity</code> 向 ATMS 发送 <code>Intent</code>。</li><li><strong>任务栈决策</strong>：ATMS 判断是否已有目标任务栈，决定复用栈顶 Activity 还是创建新任务。</li><li><strong>进程存在性检查</strong>：AMS 查询目标应用进程是否在运行。</li></ol><ul><li>存在：直接调度 Activity 生命周期。</li><li>不存在：进入进程创建流程。</li></ul><h2 id="_4-进程创建流程-冷启动核心" tabindex="-1">4. 进程创建流程（冷启动核心） <a class="header-anchor" href="#_4-进程创建流程-冷启动核心" aria-label="Permalink to &quot;4. 进程创建流程（冷启动核心）&quot;">​</a></h2><ol><li><strong>ProcessRecord 构建</strong>：AMS 构建应用的 <code>ProcessRecord</code>，准备进程启动参数（进程名、UID、SELinux 策略、<code>bindApplication</code> 数据等）。</li><li><strong>向 Zygote 发起请求</strong>：</li></ol><ul><li>调用 <code>Process.start()</code> → 通过 <code>ZygoteProcess</code> 将启动命令写入 Zygote Socket。</li><li>命令包含：进程名、<code>nice name</code>、<code>targetSdk</code>、<code>runtime flags</code>、GID 列表、调试标志等。</li></ul><ol start="3"><li><strong>Zygote fork 子进程</strong>：</li></ol><ul><li>Zygote 收到命令后执行 <code>fork()</code>。</li><li>子进程重置进程状态（UID、GID、SELinux context、nice 值），并加载应用进程入口 <code>ActivityThread</code>。</li></ul><ol start="4"><li><strong>ActivityThread main</strong>：</li></ol><ul><li>子进程调用 <code>ActivityThread.main()</code>，创建主线程（UI 线程）Looper，并向 AMS 发送 <code>attachApplication</code>。</li><li>注册 <code>ApplicationThread</code> Binder 接口，供 AMS 回调。</li></ul><ol start="5"><li><strong>AMS 绑定应用</strong>：</li></ol><ul><li>AMS 收到 <code>attachApplication</code> 后，完成与进程的双向通信绑定。</li><li>触发 <code>Instrumentation.bindApplication</code>，后续通过 <code>scheduleTransaction</code> 驱动组件生命周期。</li></ul><h2 id="_5-应用初始化顺序" tabindex="-1">5. 应用初始化顺序 <a class="header-anchor" href="#_5-应用初始化顺序" aria-label="Permalink to &quot;5. 应用初始化顺序&quot;">​</a></h2><ol><li><strong>ContentProvider 初始化</strong>：</li></ol><ul><li>AMS 在主线程调用 <code>ActivityThread.installProvider</code>，每个 Provider 执行 <code>onCreate</code>。</li><li>注意：此阶段发生在 Application <code>onCreate</code> 之前，耗时 Provider 会阻塞启动。</li></ul><ol start="2"><li><strong>Application 创建</strong>：</li></ol><ul><li>调用 <code>LoadedApk.makeApplication</code> → 执行 <code>Application.attach</code>、<code>onCreate</code>。</li><li>常见初始化操作（SDK 注册、日志系统、DI 容器）在此发生，需控制耗时与主线程阻塞。</li></ul><ol start="3"><li><strong>Activity 启动事务</strong>：</li></ol><ul><li>AMS 发出 <code>LaunchActivityItem</code> 事务。</li><li><code>ActivityThread</code> 解析事务，利用 <code>Instrumentation.newActivity</code> 反射实例化 Activity。</li><li>执行 <code>Activity.attach</code>、<code>onCreate</code>、<code>onStart</code>、<code>onResume</code>，间穿插 <code>Fragment</code> 生命周期。</li></ul><h2 id="_6-首帧呈现流程" tabindex="-1">6. 首帧呈现流程 <a class="header-anchor" href="#_6-首帧呈现流程" aria-label="Permalink to &quot;6. 首帧呈现流程&quot;">​</a></h2><ol><li><strong>setContentView 与视图创建</strong>：</li></ol><ul><li>Activity 在 <code>onCreate</code> 调用 <code>setContentView</code>，加载布局 XML、构建 View 树。</li></ul><ol start="2"><li><strong>ViewRootImpl 建立</strong>：</li></ol><ul><li><code>WindowManager</code> 将 DecorView 与 <code>ViewRootImpl</code> 绑定，发起与 WMS 的窗口同步。</li><li><code>Choreographer</code> 注册 VSync 回调，准备 UI 绘制。</li></ul><ol start="3"><li><strong>三大绘制阶段</strong>：</li></ol><ul><li><strong>measure</strong>：计算 View 尺寸。</li><li><strong>layout</strong>：确定位置。</li><li><strong>draw</strong>：生成显示列表，交给 RenderThread 或 GPU。</li></ul><ol start="4"><li><strong>SurfaceFlinger 合成</strong>：</li></ol><ul><li>RenderThread 输出图像到 Surface。</li><li><code>SurfaceFlinger</code> 将窗口合成后交给显示控制器，完成首帧展示。</li></ul><h2 id="_7-生命周期细节与关键线程" tabindex="-1">7. 生命周期细节与关键线程 <a class="header-anchor" href="#_7-生命周期细节与关键线程" aria-label="Permalink to &quot;7. 生命周期细节与关键线程&quot;">​</a></h2><ul><li><strong>主线程 (UI 线程)</strong>：负责 Activity 生命周期、View 操作、广播接收等，避免超过 16ms 的阻塞操作。</li><li><strong>Binder 线程池</strong>：处理来自系统服务的 Binder 调用（如 AMS）。</li><li><strong>RenderThread</strong>：独立于 UI 线程，执行硬件加速绘制。</li><li><strong>其他初始化线程</strong>：建议通过 <code>HandlerThread</code>、<code>Executors</code> 分担初始化逻辑，避免主线程阻塞。</li></ul><h2 id="_8-性能与优化关键点" tabindex="-1">8. 性能与优化关键点 <a class="header-anchor" href="#_8-性能与优化关键点" aria-label="Permalink to &quot;8. 性能与优化关键点&quot;">​</a></h2><ol><li><strong>Application/ContentProvider 耗时</strong>：</li></ol><ul><li>延迟初始化非关键组件，可结合 <code>App Startup</code>、<code>Jetpack Startup</code>。</li><li>使用 <code>StrictMode</code>、<code>Launch Time Report</code> 监控主线程阻塞。</li></ul><ol start="2"><li><strong>资源加载优化</strong>：</li></ol><ul><li>精简启动 Activity 布局，使用 <code>ViewStub</code>、<code>include</code> 减少层级。</li><li>合理使用 <code>VectorDrawable</code>、<code>WebP</code> 优化资源体积。</li></ul><ol start="3"><li><strong>IO 与网络</strong>：</li></ol><ul><li>启动期避免同步 IO 或网络请求，必要时降级到后台线程并提供占位 UI。</li></ul><ol start="4"><li><strong>Dex 与 ClassLoader</strong>：</li></ol><ul><li>使用 <code>Profile Guided Optimization (PGO)</code>、<code>Baseline Profiles</code> 减少类加载耗时。</li><li>对多 Dex 应用提前合并或拆分合理模块。</li></ul><ol start="5"><li><strong>进程常驻策略</strong>：</li></ol><ul><li>合理使用前台服务、WorkManager 保持常驻，但需平衡耗电与策略限制。</li></ul><h2 id="_9-启动流程时序概览" tabindex="-1">9. 启动流程时序概览 <a class="header-anchor" href="#_9-启动流程时序概览" aria-label="Permalink to &quot;9. 启动流程时序概览&quot;">​</a></h2><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>User Tap</span></span>
<span class="line"><span>  ↓</span></span>
<span class="line"><span>Launcher → ATMS/AMS → (检查或新建任务栈)</span></span>
<span class="line"><span>  ↓</span></span>
<span class="line"><span>[进程存在?]</span></span>
<span class="line"><span>  ├─是：scheduleLaunchActivity → Activity 生命周期</span></span>
<span class="line"><span>  └─否：</span></span>
<span class="line"><span>        AMS → Zygote 请求 → Zygote fork 子进程</span></span>
<span class="line"><span>          ↓</span></span>
<span class="line"><span>        ActivityThread.main → attachApplication</span></span>
<span class="line"><span>          ↓</span></span>
<span class="line"><span>        安装 ContentProvider → Application.onCreate</span></span>
<span class="line"><span>          ↓</span></span>
<span class="line"><span>        scheduleLaunchActivity → Activity onCreate/onStart/onResume</span></span>
<span class="line"><span>          ↓</span></span>
<span class="line"><span>        setContentView → View 测量布局绘制 → 首帧呈现</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h2 id="_10-监控与工具体系" tabindex="-1">10. 监控与工具体系 <a class="header-anchor" href="#_10-监控与工具体系" aria-label="Permalink to &quot;10. 监控与工具体系&quot;">​</a></h2><ul><li><strong>官方工具</strong>：<code>Android Studio Profiler</code>、<code>TraceView</code>、<code>Perfetto</code>、<code>adb shell am start -W</code>、<code>systrace</code>。</li><li><strong>日志指标</strong>：使用 <code>Logcat</code> 的 <code>ActivityTaskManager</code>、<code>ActivityManager</code> 标签获取调度信息。</li><li><strong>第三方方案</strong>：埋点统计（如 Firebase Performance）、<code>BlockCanary</code>、<code>Matrix</code> 监控阻塞。</li></ul><h2 id="_11-最佳实践清单" tabindex="-1">11. 最佳实践清单 <a class="header-anchor" href="#_11-最佳实践清单" aria-label="Permalink to &quot;11. 最佳实践清单&quot;">​</a></h2><ul><li>保持冷启动首帧 &lt; 2s，目标 700ms 以内。</li><li>避免在 Application <code>onCreate</code> 中初始化重量级 SDK（如网络、广告），采用懒加载或后台初始化。</li><li>使用 <code>SplashScreen API</code>（Android 12+）统一启动体验，结合过渡动画减少心理等待。</li><li>对关键路径建立自动化监控（CI 中通过 <code>macrobenchmark</code> 测量）并设定回归阈值。</li><li>定期审查任务栈与 Deep Link 入口，确保特殊场景（通知、ShareSheet）路径一致。</li></ul><h2 id="_12-扩展思考" tabindex="-1">12. 扩展思考 <a class="header-anchor" href="#_12-扩展思考" aria-label="Permalink to &quot;12. 扩展思考&quot;">​</a></h2><ul><li><strong>多进程应用</strong>：独立进程的 Service/Provider 会触发额外进程启动，需分离初始化逻辑。</li><li><strong>模块化架构</strong>：<code>Dynamic Feature</code> 模块延迟加载，降低冷启动体积。</li><li><strong>Compose UI</strong>：采用 <code>Jetpack Compose</code> 时关注首帧编译开销，结合 <code>remember</code>、<code>DerivedStateOf</code> 降低重组。</li><li><strong>未来趋势</strong>：App Startup 库与 Baseline Profiles 将成为启动优化标配；Android 15 引入 <code>Partial Reactivation</code> 以更高效恢复后台进程。</li></ul><hr><p>以上内容适用于主流 Android 8.0+ 系统版本，底层实现细节（如 ATMS/AMS 拆分）可能随版本微调，优化策略需结合实际硬件与业务场景验证。</p>`,60)])])}const h=o(n,[["render",t]]);export{g as __pageData,h as default};
