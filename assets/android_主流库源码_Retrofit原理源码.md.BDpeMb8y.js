import{_ as a,c as i,o as s,ai as t}from"./chunks/framework.4IxF6_6k.js";const k=JSON.parse('{"title":"Retrofit 原理与源码解读","description":"","frontmatter":{},"headers":[],"relativePath":"android/主流库源码/Retrofit原理源码.md","filePath":"android/主流库源码/Retrofit原理源码.md","lastUpdated":1759056152000}'),l={name:"android/主流库源码/Retrofit原理源码.md"};function o(n,e,r,d,c,h){return s(),i("div",null,[...e[0]||(e[0]=[t(`<h1 id="retrofit-原理与源码解读" tabindex="-1">Retrofit 原理与源码解读 <a class="header-anchor" href="#retrofit-原理与源码解读" aria-label="Permalink to &quot;Retrofit 原理与源码解读&quot;">​</a></h1><h2 id="核心概述" tabindex="-1">核心概述 <a class="header-anchor" href="#核心概述" aria-label="Permalink to &quot;核心概述&quot;">​</a></h2><p>Retrofit 基于 OkHttp 提供类型安全的 HTTP Client，通过注解驱动的接口定义 + 动态代理 + 可插拔的适配器与转换器，构建出高度可测试且易扩展的网络访问层。</p><h2 id="模块与架构" tabindex="-1">模块与架构 <a class="header-anchor" href="#模块与架构" aria-label="Permalink to &quot;模块与架构&quot;">​</a></h2><ul><li><strong>注解解析</strong>：<code>ServiceMethod</code> 负责解析接口方法上的 HTTP 注解、参数注解并缓存结果。</li><li><strong>动态代理</strong>：<code>Proxy.newProxyInstance</code> 拦截接口调用，交由 <code>InvocationHandler</code> 执行。</li><li><strong>请求构建</strong>：<code>RequestFactory</code> 将注解信息转换为 <code>okhttp3.Request</code>。</li><li><strong>调用执行</strong>：默认使用 <code>OkHttpCall</code>，也可通过 <code>CallAdapter</code> 自定义返回类型（如 RxJava、协程）。</li><li><strong>数据转换</strong>：<code>Converter</code> 将请求 / 响应在 Java/Kotlin 对象与网络传输格式间转换。</li></ul><h2 id="核心调用链" tabindex="-1">核心调用链 <a class="header-anchor" href="#核心调用链" aria-label="Permalink to &quot;核心调用链&quot;">​</a></h2><ol><li><code>Retrofit.create(FooService.class)</code> 生成接口的动态代理；服务方法的解析结果缓存在 <code>ServiceMethodCache</code>。</li><li>业务层调用接口方法被代理拦截，转交 <code>ServiceMethod.invoke</code>。</li><li><code>ServiceMethod</code> 根据入参组装 <code>okhttp3.Request</code>，并委托 <code>CallAdapter</code> 得到最终返回类型。</li><li>默认 <code>CallAdapter</code> 返回 <code>OkHttpCall</code>，其 <code>enqueue</code> / <code>execute</code> 又会落到 OkHttp 的异步/同步请求流程。</li></ol><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Retrofit 动态代理核心逻辑（删减版，中文注释保留关键点）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Object </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">invoke</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Object proxy, Method method, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] args) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ServiceMethod&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; serviceMethod </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> loadServiceMethod</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(method); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 解析并缓存注解</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    OkHttpCall&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; call </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> OkHttpCall&lt;&gt;(serviceMethod, args); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 构建 OkHttpCall</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> serviceMethod.callAdapter.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">adapt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(call);                </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 适配返回类型</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="关键源码细节" tabindex="-1">关键源码细节 <a class="header-anchor" href="#关键源码细节" aria-label="Permalink to &quot;关键源码细节&quot;">​</a></h2><ul><li><strong>注解处理</strong>：<code>RequestFactory.Builder</code> 会遍历方法注解确认 HTTP 动词、路径、查询参数等；参数注解决定如何注入到请求。</li><li><strong>缓存策略</strong>：<code>ServiceMethodCache</code> 使用 <code>ConcurrentHashMap</code>，保证首次解析后即可复用，降低反射开销。</li><li><strong>异常包装</strong>：通过 <code>HttpException</code>、<code>InvocationException</code> 统一抛出网络/解析错误，便于上层区分。</li></ul><h2 id="扩展与实践" tabindex="-1">扩展与实践 <a class="header-anchor" href="#扩展与实践" aria-label="Permalink to &quot;扩展与实践&quot;">​</a></h2><ul><li>配置 <code>Converter.Factory</code> 支持 JSON（Gson/Moshi）或 ProtoBuf；自定义 <code>RequestBody</code> 编码。</li><li>编写 <code>CallAdapter.Factory</code> 适配协程 <code>suspend</code>、<code>LiveData</code> 或 <code>Flow</code> 返回类型。</li><li>结合 OkHttp 拦截器完成统一 Header、签名、埋点与日志。</li></ul><h2 id="风险与优化建议" tabindex="-1">风险与优化建议 <a class="header-anchor" href="#风险与优化建议" aria-label="Permalink to &quot;风险与优化建议&quot;">​</a></h2><ul><li><strong>线程调度</strong>：Retrofit 不负责线程切换，需在 <code>CallAdapter</code> 层处理（如 RxJava Scheduler 或协程 <code>Dispatcher</code>）。</li><li><strong>错误处理</strong>：建议统一封装响应模型（Result/ApiResponse），避免在业务层重复解析异常。</li><li><strong>性能</strong>：避免在 <code>Converter</code> 内进行大对象拷贝；对响应流采用流式解析（如 Moshi 的流 API）。</li></ul><h2 id="调试方法" tabindex="-1">调试方法 <a class="header-anchor" href="#调试方法" aria-label="Permalink to &quot;调试方法&quot;">​</a></h2><ul><li>开启 OkHttp <code>HttpLoggingInterceptor</code> 或自定义网络日志。</li><li>在 <code>CallAdapter</code> 层测量耗时，结合埋点分析慢接口。</li><li>配合 MockWebServer 做集成测试，验证注解配置与解析结果。</li></ul>`,16)])])}const g=a(l,[["render",o]]);export{k as __pageData,g as default};
